def find_password():
    print("What is your password:")
    pwd = input().strip()

    # # ğŸ DEBUG: Show entered password length (not the password itself for security)
    # print(f"ğŸ DEBUG: Password input length = {len(pwd)} characters")

    return pwd


def get_password():
    while True:
        print("Choose a password:")
        pwd = input().strip()

        # # ğŸ DEBUG: Check password candidate length for early insight
        # print(f"ğŸ DEBUG: Attempted password length = {len(pwd)}")

        if validate_password(pwd):
            # ğŸ DEBUG: Password validated successfully
            # print("ğŸ DEBUG: Password passed validation.")
            return pwd
        else:
            print("Please try again with a stronger password.\n")


def validate_password(password):
    special_chars = set("!@#$%^&*()-_=+[]{}|;:'\",.<>/?`~\\")  # Step 1

    has_upper = any(c.isupper() for c in password)              # Step 2
    has_lower = any(c.islower() for c in password)              # Step 3
    has_digit = any(c.isdigit() for c in password)              # Step 4
    has_special = any(c in special_chars for c in password)     # Step 5
    is_long_enough = len(password) > 8                          # Step 6

    if all([has_upper, has_lower, has_digit, has_special, is_long_enough]):  # Step 7
        print("Great password!")
        return True
    else:
        print("Password requirements not met:")                # Step 8
        if not has_upper:
            print("- At least one uppercase letter needed")
        if not has_lower:
            print("- At least one lowercase letter needed")
        if not has_digit:
            print("- At least one digit needed")
        if not has_special:
            print("- At least one special character needed")
        if not is_long_enough:
            print("- Password must be longer than 8 characters")

        # # ğŸ DEBUG: Validation flags
        # print(f"ğŸ DEBUG: Flags -> upper:{has_upper}, lower:{has_lower}, digit:{has_digit}, special:{has_special}, length:{is_long_enough}")
        return False
